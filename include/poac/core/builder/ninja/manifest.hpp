#ifndef POAC_CORE_BUILDER_NINJA_MANIFEST_HPP
#define POAC_CORE_BUILDER_NINJA_MANIFEST_HPP

// std
#include <array>
#include <fstream>
#include <utility> // std::make_pair

// external
#include <boost/algorithm/string.hpp> // boost::algorithm::join
#include <ninja/build.h>              // Builder
#include <ninja/graph.h>              // Node
#include <toml.hpp>

// internal
#include <poac/config.hpp>
#include <poac/core/builder/compiler.hpp>
#include <poac/core/builder/ninja/data.hpp>
#include <poac/core/builder/ninja/syntax.hpp>
#include <poac/core/resolver.hpp> // resolved_deps_t, get_extracted_path
#include <poac/data/manifest.hpp>
#include <poac/poac.hpp>
#include <poac/util/cfg.hpp>
#include <poac/util/misc.hpp>

namespace poac::core::builder::ninja::manifest {

inline const String manifest_file_name = "ninja.build";
inline const std::array<String, 2> manifest_headers = {
    "This file is automatically generated by Poac.",
    "It is not intended for manual editing."};

inline fs::file_time_type
ninja_manifest_last_modified(const fs::path& build_dir) {
  return fs::last_write_time(build_dir / manifest_file_name);
}

inline bool
is_outdated(const fs::path& build_dir) {
  if (!fs::exists(build_dir / manifest_file_name)) {
    return true;
  }
  using poac::data::manifest::poac_toml_last_modified;
  return ninja_manifest_last_modified(build_dir) <
         poac_toml_last_modified(config::path::cur_dir);
}

bool
rebuild(data::NinjaMain& ninja_main, Status& status, String& err) {
  Node* node = ninja_main.state.LookupNode(
      (ninja_main.build_dir / manifest_file_name).string()
  );
  if (!node) {
    return false;
  }

  Builder builder(
      &ninja_main.state, ninja_main.config, &ninja_main.build_log,
      &ninja_main.deps_log, &ninja_main.disk_interface, &status,
      ninja_main.start_time_millis
  );
  if (!builder.AddTarget(node, &err)) {
    return false;
  }
  if (builder.AlreadyUpToDate()) {
    return false; // Not an error, but we didn't rebuild.
  }
  if (!builder.Build(&err)) {
    return false;
  }

  // The manifest was only rebuilt if it is now dirty (it may have been cleaned
  // by a restat).
  if (!node->dirty()) {
    // Reset the state to prevent problems like
    // https://github.com/ninja-build/ninja/issues/874
    ninja_main.state.Reset();
    return false;
  }
  return true;
}

Vec<String>
gather_includes(const resolver::ResolvedDeps& resolved_deps) {
  Vec<String> includes;
  for (const auto& [package, inner_deps] : resolved_deps) {
    static_cast<void>(inner_deps);

    const auto include_path = resolver::get_extracted_path(package) / "include";
    if (fs::exists(include_path) && fs::is_directory(include_path)) {
      includes.emplace_back(format("-I{}", include_path.string()));
    }
  }
  return includes;
}

Vec<toml::table>
get_cfg_profile(const toml::value& poac_manifest) {
  const auto target =
      toml::find_or<toml::table>(poac_manifest, "target", toml::table{});
  Vec<toml::table> profiles;
  for (const auto& [key, val] : target) {
    if (key.find("cfg(") != SNone) {
      if (util::cfg::parse(key).match()) {
        const auto profile =
            toml::find_or<toml::table>(val, "profile", toml::table{});
        profiles.emplace_back(profile);
      }
    }
  }
  return profiles;
}

Vec<String>
gather_flags(
    const toml::value& poac_manifest, const String& name,
    const Option<String>& prefix = None
) {
  auto f = toml::find_or<Vec<String>>(
      poac_manifest, "target", "profile", name, Vec<String>{}
  );
  if (prefix.has_value()) {
    std::transform(
        f.begin(), f.end(), f.begin(),
        [p = prefix.value()](const auto& s) { return p + s; }
    );
  }
  return f;
}

[[nodiscard]] Result<String>
construct(
    const fs::path& build_dir, const toml::value& poac_manifest,
    const resolver::ResolvedDeps& resolved_deps
) {
  syntax::Writer writer{std::ostringstream()};
  for (const auto& header : manifest_headers) {
    writer.comment(header);
  }
  writer.newline();

  const auto cpp = toml::find<toml::integer>(poac_manifest, "package", "cpp");
  const String command = Try(compiler::cxx::get_command(cpp, false));

  writer.rule(
      "compile",
      format("{} $OPTIONS $DEFINES $INCLUDES $LIBRARIES $in -o $out", command),
      syntax::RuleSet{
          .description = "$PACKAGE_NAME v$PACKAGE_VERSION $PACKAGE_PATH",
      }
  );
  writer.newline();

  const fs::path source_file = "src"_path / "main.cpp";
  const fs::path output_file = (build_dir / source_file).string() + ".o";
  fs::create_directories(output_file.parent_path());
  const auto includes = gather_includes(resolved_deps);

  const auto defines = gather_flags(poac_manifest, "definitions", "-D");
  const auto options = gather_flags(poac_manifest, "options");
  const auto libraries = gather_flags(poac_manifest, "libraries", "-l");

  writer.build(
      {output_file.string()}, "compile",
      syntax::BuildSet{
          .inputs = std::vector{source_file.string()},
          .variables =
              syntax::Variables{
                  {"PACKAGE_NAME",
                   toml::find<String>(poac_manifest, "package", "name")},
                  {"PACKAGE_VERSION",
                   toml::find<String>(poac_manifest, "package", "version")},
                  {"PACKAGE_PATH",
                   format("({})", config::path::cur_dir.string())},
                  {"OPTIONS", boost::algorithm::join(options, " ")},
                  {"DEFINES", boost::algorithm::join(defines, " ")},
                  {"INCLUDES", boost::algorithm::join(includes, " ")},
                  {"LIBRARIES", boost::algorithm::join(libraries, " ")},
              },
      }
  );
  writer.newline();

  writer.default_({output_file.string()});
  return Ok(writer.get_value());
}

[[nodiscard]] Result<void>
create(
    const fs::path& build_dir, const toml::value& poac_manifest,
    const resolver::ResolvedDeps& resolved_deps
) {
  // `ninja.build` will be constructed from `poac.toml`,
  // so if `poac.toml` has no change,
  // then `ninja.build` is not needed to be updated.
  //        if (is_outdated(build_dir)) {
  std::ofstream ofs(build_dir / manifest_file_name, std::ios::out);
  ofs << Try(construct(build_dir, poac_manifest, resolved_deps));
  //        }
  return Ok();
}

} // namespace poac::core::builder::ninja::manifest

#endif // !POAC_CORE_BUILDER_NINJA_MANIFEST_HPP
